// <copyright file="Generator.cs">
// Copyright (c) 2022-23 Dmitry Kolchev. All rights reserved.
// See LICENSE in the project root for license information
// </copyright>

using System;
using Neutrino.Psi.Executive;


namespace Neutrino.Psi.Components;

/// <summary>
/// Generates a sequence of messages at the pace dictated by the pipeline.
/// Use this base class when your generator has multiple output streams.
/// Use the static functions of the <see cref="Generators"/> class for the single-stream case.
/// </summary>
/// <remarks>
/// When playing back data from offline sources, it is typically desirable that data not be dropped
/// even when resource constraints prevent the pipeline from running in real time.
/// Thus, source components that generate data from offline sources (e.g. from a file)
/// must be able to slow down production of data as requested by the hosting pipeline.
/// Since the runtime will not interfere with any threads it doesn’t own (by design),
/// reading and publishing offline data on a dedicated thread doesn't achieve the desired effect.
/// Rather, such source components must implement the Generator pattern, in which an internal emitter/receiver
/// pair is used to yield back to the runtime.
/// The following example shows how to implement a multi-stream generator:
/// /include ..\..\Test.Psi\GeneratorSample.cs.
/// </remarks>
public abstract class Generator : ISourceComponent
{
    private readonly Receiver<int> _loopBackIn;
    private readonly Emitter<int> _loopBackOut;
    private readonly Pipeline _pipeline;
    private readonly string _name;
    private readonly PipelineElement _node;
    private readonly bool _isInfiniteSource;
    private bool _stopped;
    private Action<DateTime> _notifyCompletionTime;
    private Action _notifyCompleted;
    private DateTime _finalMessageTime = DateTime.MaxValue;
    private DateTime _nextMessageOriginatingTime = DateTime.MinValue;

    /// <summary>
    /// Initializes a new instance of the <see cref="Generator"/> class.
    /// </summary>
    /// <param name="pipeline">The pipeline to add the component to.</param>
    /// <param name="isInfiniteSource">If true, mark this Generator instance as representing an infinite source (e.g., a live-running sensor).
    /// If false (default), it represents a finite source (e.g., Generating messages based on a finite file or IEnumerable).</param>
    /// <param name="name">An optional name for the generator.</param>
    public Generator(Pipeline pipeline, bool isInfiniteSource = false, string name = nameof(Generator))
    {
        _loopBackOut = pipeline.CreateEmitter<int>(this, nameof(_loopBackOut));
        _loopBackIn = pipeline.CreateReceiver<int>(this, Next, nameof(_loopBackIn));
        _loopBackOut.PipeTo(_loopBackIn, DeliveryPolicy.Unlimited);
        _pipeline = pipeline;
        _name = name;
        _node = pipeline.GetOrCreateNode(this);
        _isInfiniteSource = isInfiniteSource;
    }

    /// <inheritdoc />
    public void Start(Action<DateTime> notifyCompletionTime)
    {
        _notifyCompletionTime = notifyCompletionTime;

        // If this is an infinite source *and* the pipeline does not specify a finite replay interval,
        // then we can notify completion with MaxValue now to notify the pipeline that this component
        // will not terminate until the pipeline is explicitly stopped. Otherwise, we will notify later
        // once we have completed generating all messages within the pipeline's replay interval.
        if (_isInfiniteSource && _pipeline.ReplayDescriptor.End == DateTime.MaxValue)
        {
            _notifyCompletionTime(DateTime.MaxValue);
        }
        else
        {
            // ensure that messages are not posted past the end of the replay descriptor
            _finalMessageTime = _pipeline.ReplayDescriptor.End;
        }

        Envelope firstEnvelope = default;

        if (_pipeline.ReplayDescriptor.Start == DateTime.MinValue)
        {
            firstEnvelope.OriginatingTime = _pipeline.StartTime;
        }
        else
        {
            firstEnvelope.OriginatingTime = _pipeline.ReplayDescriptor.Start;
        }

        _loopBackOut.Post(0, firstEnvelope.OriginatingTime);
    }

    /// <inheritdoc />
    public void Stop(DateTime finalOriginatingTime, Action notifyCompleted)
    {
        // If the generator has already stopped, call notify completed.
        // This is for now handling a problem that is actually generated by
        // the stream importers telling the pipeline that they stopped after
        // the replay interval. We need to think more deeply about how to
        // solve the problem, what exactly is the semantics of the replay
        // interval (e.g. originating time or wall-clock) and how it relates
        // to the final originating time for the pipeline and individual
        // components.
        if (_stopped)
        {
            notifyCompleted.Invoke();
            return;
        }

        _finalMessageTime = finalOriginatingTime;
        _notifyCompleted = notifyCompleted;

        // if next message would be past the final message time, stop immediately and notify completion
        if (_nextMessageOriginatingTime > _finalMessageTime)
        {
            _stopped = true;
            _notifyCompleted();
        }
    }

    /// <inheritdoc/>
    public override string ToString()
    {
        return _name;
    }

    /// <summary>
    /// Function that gets called to produce more data once the pipeline is ready to consume it.
    /// Override to post data to the appropriate stream.
    /// </summary>
    /// <param name="currentTime">The originating time of the message that triggered the current call to GenerateNext.</param>
    /// <returns>
    /// The originating time of the next message that will trigger the next call to GenerateNext.
    /// The next call will occur only after this time (based on the pipeline clock).
    /// </returns>
    protected abstract DateTime GenerateNext(DateTime currentTime);

    private void Next(int counter, Envelope envelope)
    {
        if (_stopped)
        {
            return;
        }

        try
        {
            _nextMessageOriginatingTime = GenerateNext(envelope.OriginatingTime);

            // impose strictly increasing times for the loopback message as required by the runtime
            if (_nextMessageOriginatingTime <= envelope.OriginatingTime)
            {
                _nextMessageOriginatingTime = envelope.OriginatingTime.AddTicks(1);
            }

            // stop if nextMessageTime is past finalMessageTime or is equal to DateTime.MaxValue (which indicates that there is no more data)
            if (_nextMessageOriginatingTime > _finalMessageTime || _nextMessageOriginatingTime == DateTime.MaxValue)
            {
                _stopped = true;

                // get the latest message time from all of this component's emitters
                var finalOriginatingTime = _node.LastOutputEnvelope.OriginatingTime;

                // notify the pipeline of the originating time of the final message from this component
                _notifyCompletionTime(finalOriginatingTime);

                // additionally notify completed if we have already been requested by the pipeline to stop
                _notifyCompleted?.Invoke();
                return;
            }

            _loopBackOut.Post(counter + 1, _nextMessageOriginatingTime);
        }
        catch
        {
            // If the loopback function throws, we must terminate the generator immediately since we cannot guarantee
            // the delivery of any further loopback messages. The pipeline will attempt to stop all source components
            // (including this generator), so setting this.nextMessageTime to DateTime.MaxValue signals to the component
            // to call notifyCompleted as soon as the pipeline calls its Stop() method, rather than wait for further
            // loopback messages pending completion (since there won't be any forthcoming).
            _nextMessageOriginatingTime = DateTime.MaxValue;
            throw;
        }
    }
}
